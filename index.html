<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ï¥àÎì± 5ÌïôÎÖÑ ÎÇ†Ïî® Ìå°Ìå°</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Fredoka+One&family=Jua&family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (for JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body {
        font-family: 'Jua', sans-serif;
        overflow-x: hidden; /* Í∞ÄÎ°ú Ïä§ÌÅ¨Î°§ Î∞©ÏßÄ */
        touch-action: manipulation; /* Î™®Î∞îÏùº ÌÑ∞Ïπò ÏµúÏ†ÅÌôî */
      }
      .font-fredoka {
        font-family: 'Fredoka One', cursive;
      }
      .font-nunito {
        font-family: 'Nunito', sans-serif;
      }
      .font-black-han {
        font-family: 'Black Han Sans', sans-serif;
      }
      @keyframes pulse-grow {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.1); }
      }
      @keyframes twinkle {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.6; transform: scale(0.95); }
      }
      @keyframes gentle-rotate {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }
      @keyframes wiggle {
        0%, 100% { transform: rotate(0deg); }
        25% { transform: rotate(-6deg); }
        75% { transform: rotate(6deg); }
      }
      @keyframes sway {
        0%, 100% { transform: translateX(0); }
        50% { transform: translateX(6%); }
      }
      @keyframes bomb-explode {
        0% { transform: scale(1); filter: brightness(1); }
        50% { transform: scale(1.4) rotate(10deg); filter: brightness(3); }
        100% { transform: scale(0) rotate(-10deg); filter: brightness(1); }
      }
      @keyframes hint-glow {
        0%, 100% {
          box-shadow: 0 0 0px 0px rgba(239, 68, 68, 0);
          transform: scale(1);
          background-color: rgba(255, 255, 255, 0.8);
        }
        50% {
          box-shadow: 0 0 25px 15px rgba(239, 68, 68, 0.6);
          transform: scale(1.15);
          background-color: rgba(239, 68, 68, 0.85);
        }
      }
      .animate-bomb-explode {
        animation: bomb-explode 0.4s ease-out forwards;
      }
      .animate-hint-glow {
        animation: hint-glow 1.5s infinite ease-in-out;
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react/": "https://aistudiocdn.com/react@^19.2.1/",
    "react": "https://aistudiocdn.com/react@^19.2.1",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.1/"
  }
}
</script>
</head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useCallback, useRef } = React;

      // --- Types (Simulated Enums) ---
      const GameState = {
        Menu: 0,
        Playing: 1,
        GameOver: 2,
      };

      // --- Constants ---
      const INITIAL_MOVES = 30; // ÏïΩÍ∞Ñ Ï°∞Ï†ï (Í≤åÏûÑ Î∞∏Îü∞Ïä§)
      const BOARD_SIZE = 7;
      const MIN_MATCH_LENGTH = 3;
      const BOMB_ICON = 'üí£';
      const BOMB_CHANCE = 0.03;

      const THEMES = [
        {
          name: 'ÎßëÏùÄ ÎÇ†',
          icon: '‚òÄÔ∏è',
          pieces: ['‚òÄÔ∏è', '‚òÅÔ∏è', 'üíß', 'üí®', 'üåà', '‚≠ê'],
        },
        {
          name: 'ÎπÑ Ïò§Îäî ÎÇ†',
          icon: 'üåßÔ∏è',
          pieces: ['üåßÔ∏è', 'üíß', '‚ö°', '‚òÇÔ∏è', 'üå¨Ô∏è', 'üåä'],
        },
        {
          name: 'Í≥ÑÏ†àÏùò Î≥ÄÌôî',
          icon: 'üçÇ',
          pieces: ['üå∏', '‚òÄÔ∏è', 'üçÅ', '‚ùÑÔ∏è', 'üå±', 'üçÉ'],
        },
      ];

      // --- Quiz Data ---
      const QUIZ_QUESTIONS = [
        {
            question: "Í∏∞Ïò®ÏùÑ Ï∏°Ï†ïÌïòÎäî ÎèÑÍµ¨Îäî Î¨¥ÏóáÏùºÍπåÏöî?",
            options: ["Ïò®ÎèÑÍ≥Ñ", "ÏäµÎèÑÍ≥Ñ", "ÌíçÌñ•Í≥Ñ", "Í∏∞ÏïïÍ≥Ñ"],
            correctAnswer: "Ïò®ÎèÑÍ≥Ñ",
        },
        {
            question: "Î∞îÎûåÏù¥ Î∂àÏñ¥Ïò§Îäî Î∞©Ìñ•ÏùÑ ÏïÑÎäî Îç∞ ÏÇ¨Ïö©ÌïòÎäî ÎèÑÍµ¨Îäî Î¨¥ÏóáÏùºÍπåÏöî?",
            options: ["ÌíçÏÜçÍ≥Ñ", "Ïò®ÎèÑÍ≥Ñ", "ÌíçÌñ•Í≥Ñ", "ÏäµÎèÑÍ≥Ñ"],
            correctAnswer: "ÌíçÌñ•Í≥Ñ",
        },
        {
            question: "Í≥µÍ∏∞ Ï§ëÏóê Ìè¨Ìï®Îêú ÏàòÏ¶ùÍ∏∞Ïùò ÏñëÏùÑ Î¨¥ÏóáÏù¥ÎùºÍ≥† Ìï†ÍπåÏöî?",
            options: ["Í∏∞Ïò®", "ÏäµÎèÑ", "Í∏∞Ïïï", "ÌíçÏÜç"],
            correctAnswer: "ÏäµÎèÑ",
        },
        {
            question: "Íµ¨Î¶ÑÏóêÏÑú ÎïÖÏúºÎ°ú Îñ®Ïñ¥ÏßÄÎäî ÎπÑ, Îàà, Ïö∞Î∞ï Îì±ÏùÑ ÌÜµÌãÄÏñ¥ Î¨¥ÏóáÏù¥ÎùºÍ≥† Ìï†ÍπåÏöî?",
            options: ["ÏùëÍ≤∞", "Ï¶ùÎ∞ú", "Í∞ïÏàò", "Î∞îÎûå"],
            correctAnswer: "Í∞ïÏàò",
        },
        {
            question: "Îã§Ïùå Ï§ë ÏäµÎèÑÍ∞Ä ÎÜíÏùÑ Îïå ÎÇòÌÉÄÎÇòÎäî ÌòÑÏÉÅÏùÄ?",
            options: ["Í≥∞Ìå°Ïù¥Í∞Ä Ïûò ÏÉùÍ∏¥Îã§.", "ÌîºÎ∂ÄÍ∞Ä Í±¥Ï°∞Ìï¥ÏßÑÎã§.", "Îπ®ÎûòÍ∞Ä Ïûò ÎßàÎ•∏Îã§.", "ÏÇ∞Î∂àÏù¥ ÎÇòÍ∏∞ ÏâΩÎã§."],
            correctAnswer: "Í≥∞Ìå°Ïù¥Í∞Ä Ïûò ÏÉùÍ∏¥Îã§.",
        },
        {
            question: "Í≥µÍ∏∞ Ï§ëÏùò ÏàòÏ¶ùÍ∏∞Í∞Ä Î¨ºÎ∞©Ïö∏Î°ú Î≥ÄÌïòÎäî ÌòÑÏÉÅÏùÄ Î¨¥ÏóáÏùºÍπåÏöî?",
            options: ["Ï¶ùÎ∞ú", "ÏùëÍ≤∞", "Í∞ïÏàò", "Í∏∞Ìôî"],
            correctAnswer: "ÏùëÍ≤∞",
        },
        {
            question: "ÌïòÎ£® Ï§ë Í∏∞Ïò®Ïù¥ Í∞ÄÏû• ÎÜíÏùÑ ÎïåÎäî Î≥¥ÌÜµ Ïñ∏Ï†úÏùºÍπåÏöî?",
            options: ["Ïò§Ï†Ñ 9~10Ïãú", "Ï†ïÏò§", "Ïò§ÌõÑ 2~3Ïãú", "Ï†ÄÎÖÅ 6Ïãú"],
            correctAnswer: "Ïò§ÌõÑ 2~3Ïãú",
        },
        {
            question: "Ïö∞Î¶¨ÎÇòÎùºÏóê Ïó¨Î¶ÑÏ≤†Ïóê ÎßéÏùÄ ÎπÑÎ•º ÎÇ¥Î¶¨Í≤å ÌïòÎäî Í≥µÍ∏∞ Îç©Ïñ¥Î¶¨Ïùò ÏÑ±ÏßàÏùÄ?",
            options: ["Ï∞®Í≥† Í±¥Ï°∞ÌïòÎã§", "Ï∞®Í≥† ÏäµÌïòÎã§", "Îî∞ÎúªÌïòÍ≥† Í±¥Ï°∞ÌïòÎã§", "Îî∞ÎúªÌïòÍ≥† ÏäµÌïòÎã§"],
            correctAnswer: "Îî∞ÎúªÌïòÍ≥† ÏäµÌïòÎã§",
        },
        {
            question: "Í≤®Ïö∏Ï≤† ÎÇ†Ïî®Ïóê ÏòÅÌñ•ÏùÑ Ï£ºÎäî Ï∞®Í≥† Í±¥Ï°∞Ìïú Í≥µÍ∏∞ Îç©Ïñ¥Î¶¨Îäî Ïñ¥ÎîîÏóêÏÑú Ïò§ÎÇòÏöî?",
            options: ["ÌÉúÌèâÏñë", "ÏãúÎ≤†Î¶¨ÏïÑ", "Ïù∏ÎèÑÏñë", "Î∂ÅÍ∑πÌï¥"],
            correctAnswer: "ÏãúÎ≤†Î¶¨ÏïÑ",
        },
        {
            question: "Í∞ïÌïú Î∞îÎûåÍ≥º ÎßéÏùÄ ÎπÑÎ•º ÎèôÎ∞òÌïòÎ©∞ Ï§ëÏã¨Î∂ÄÍ∞Ä Í≥†ÏöîÌïú ÏûêÏó∞ ÌòÑÏÉÅÏùÄ?",
            options: ["Ìô©ÏÇ¨", "ÌÉúÌíç", "Ïû•Îßà", "Ìè≠ÏÑ§"],
            correctAnswer: "ÌÉúÌíç",
        },
        {
            question: "ÏïàÍ∞úÍ∞Ä ÏûêÏ£º Î∞úÏÉùÌïòÎäî Í≥ÑÏ†àÏùÄ Ïñ∏Ï†úÏùºÍπåÏöî?",
            options: ["Ïó¨Î¶ÑÍ≥º Í≤®Ïö∏", "Î¥ÑÍ≥º Í∞ÄÏùÑ", "Ïó¨Î¶ÑÏóêÎßå", "Í≤®Ïö∏ÏóêÎßå"],
            correctAnswer: "Î¥ÑÍ≥º Í∞ÄÏùÑ",
        },
        {
            question: "ÎπÑÍ∞Ä ÎÇ¥Î¶∞ Îí§ ÎßëÍ≤å Í∞† ÌïòÎäòÏóêÏÑú Î≥º Ïàò ÏûàÎäî ÏùºÍ≥± ÎπõÍπîÏùò Îù†Îäî Î¨¥ÏóáÏùºÍπåÏöî?",
            options: ["Ïò§Î°úÎùº", "Ïã†Í∏∞Î£®", "Î¨¥ÏßÄÍ∞ú", "ÎÖ∏ÏùÑ"],
            correctAnswer: "Î¨¥ÏßÄÍ∞ú",
        },
        {
            question: "ÏßÄÌëúÎ©¥ Í∞ÄÍπåÏö¥ Í≥µÍ∏∞ Ï§ëÏùò ÏàòÏ¶ùÍ∏∞Í∞Ä ÏùëÍ≤∞ÌïòÏó¨ ÏãúÏïºÍ∞Ä ÌùêÎ†§ÏßÄÎäî ÌòÑÏÉÅÏùÄ?",
            options: ["Ïù¥Ïä¨", "ÏïàÍ∞ú", "ÏÑúÎ¶¨", "Î¨¥ÏßÄÍ∞ú"],
            correctAnswer: "ÏïàÍ∞ú",
        },
        {
            question: "Î∞îÎûåÏùò Îπ†Î•¥Í∏∞Î•º Ï∏°Ï†ïÌïòÎäî ÎèÑÍµ¨Îäî Î¨¥ÏóáÏùºÍπåÏöî?",
            options: ["ÌíçÌñ•Í≥Ñ", "Í∏∞ÏïïÍ≥Ñ", "Ïò®ÎèÑÍ≥Ñ", "ÌíçÏÜçÍ≥Ñ"],
            correctAnswer: "ÌíçÏÜçÍ≥Ñ",
        },
        {
            question: "Í≥µÍ∏∞ Ï§ëÏùò ÏàòÏ¶ùÍ∏∞Í∞Ä ÏùëÍ≤∞Ìï¥ ÏûëÏùÄ Î¨ºÎ∞©Ïö∏Ïù¥ÎÇò ÏûëÏùÄ ÏñºÏùå ÏïåÍ∞±Ïù¥Î°ú ÌïòÎäòÏóê Î¨¥Î¶¨ÏßÄÏñ¥ Îñ† ÏûàÎäî Í≤ÉÏùÄ?",
            options: ["Íµ¨Î¶Ñ", "ÏïàÍ∞ú", "Ïù¥Ïä¨", "ÏàòÏ¶ùÍ∏∞"],
            correctAnswer: "Íµ¨Î¶Ñ",
        },
        {
            question: "Ïû•ÎßàÏ≤†Ïóê Ïö∞Î¶¨ÎÇòÎùºÏóê ÏòÅÌñ•ÏùÑ Ï£ºÎäî Í≤ÉÏùÄ Î¨¥ÏóáÏù∏Í∞ÄÏöî?",
            options: ["Í≥†Í∏∞Ïïï", "Ï†ÄÍ∏∞Ïïï", "Ïû•ÎßàÏ†ÑÏÑ†", "ÌÉúÌíç"],
            correctAnswer: "Ïû•ÎßàÏ†ÑÏÑ†",
        },
        {
            question: "ÏùºÏ†ïÌïú ÏßÄÏó≠ÏóêÏÑú Ïò§Îûú Í∏∞Í∞ÑÏóê Í±∏Ï≥ê ÎÇòÌÉÄÎÇòÎäî ÌèâÍ∑†Ï†ÅÏù∏ ÎÇ†Ïî® ÏÉÅÌÉúÎ•º Î¨¥ÏóáÏù¥ÎùºÍ≥† Ìï†ÍπåÏöî?",
            options: ["Í∏∞ÏÉÅ", "ÏùºÍ∏∞", "Í∏∞ÌõÑ", "Í≥ÑÏ†à"],
            correctAnswer: "Í∏∞ÌõÑ",
        },
        {
            question: "Íµ¨Î¶Ñ ÏÜç ÏñºÏùåÏïåÍ∞±Ïù¥Í∞Ä Ïª§ÏßÑ Îí§ Î¨¥Í±∞ÏõåÏ†∏ Îñ®Ïñ¥ÏßàÎïå ÎÖπÏßÄ ÏïäÏùÄ Í≤ÉÏùÄ?",
            options: ["ÎπÑ", "Ïö∞Î∞ï", "ÏÑúÎ¶¨", "Îàà"],
            correctAnswer: "Îàà",
        },
        {
            question: "Ïù¥Ïä¨Ïù¥ ÏñºÏñ¥ÏÑú ÏÉùÍ∏¥ ÌïòÏñÄ ÏïåÍ∞±Ïù¥Î•º Î¨¥ÏóáÏù¥ÎùºÍ≥† Ìï†ÍπåÏöî?",
            options: ["Îàà", "Ïö∞Î∞ï", "ÏßÑÎààÍπ®ÎπÑ", "ÏÑúÎ¶¨"],
            correctAnswer: "ÏÑúÎ¶¨",
        },
        {
            question: "Íµ¨Î¶Ñ ÏÜç Î¨ºÎ∞©Ïö∏Ïù¥ Ìï©Ï≥êÏ†∏ Î¨¥Í±∞ÏõåÏ†∏ Í∑∏ÎåÄÎ°ú Îñ®Ïñ¥ÏßÑ Í≤ÉÏùÄ?",
            options: ["ÎπÑ", "Ïù¥Ïä¨", "ÏïàÍ∞ú", "Îàà"],
            correctAnswer: "ÎπÑ",
        },
        {
            question: "Í≥µÍ∏∞Ïùò Î¨¥Í≤åÎ°ú ÏÉùÍ∏∞Îäî ÌûòÏùÄ?",
            options: ["Í∏∞Ïïï", "ÏäµÎèÑ", "ÌíçÏÜç", "Ï§ëÎ†•"],
            correctAnswer: "Í∏∞Ïïï",
        },
        {
            question: "ÏÉÅÎåÄÏ†ÅÏúºÎ°ú Îî∞ÎúªÌïú Í≥µÍ∏∞Îäî Ï∞®Í∞ÄÏö¥ Í≥µÍ∏∞Î≥¥Îã§ Í∏∞ÏïïÏù¥ ÎÇÆÏùÄÎç∞ Ïù¥Í≤ÉÏùÄ?",
            options: ["Í≥†Í∏∞Ïïï", "Ï†ÄÍ∏∞Ïïï", "Ï†ÑÏÑ†", "ÎÇúÍ∏∞Î•ò"],
            correctAnswer: "Ï†ÄÍ∏∞Ïïï",
        },
        {
            question: "Îëê ÏßÄÏó≠ Í∞ÑÏóê Í∏∞ÏïïÏ∞®Ïù¥Í∞Ä ÏÉùÍ∏∞Î©¥ Í≥µÍ∏∞Í∞Ä Ïù¥ÎèôÌïòÎäîÎç∞ Ïù¥Í±∏ Î≠êÎùºÌïòÎÇòÏöî?",
            options: ["Í∏∞Î•ò", "Ìï¥Î•ò", "Ï†ÑÏÑ†", "Î∞îÎûå"],
            correctAnswer: "Î∞îÎûå",
        },
        {
            question: "Î∞îÎûåÏùÄ Í≥†Í∏∞ÏïïÏóêÏÑú Ïñ¥ÎîîÎ°ú Ïù¥ÎèôÌïòÎÇòÏöî?",
            options: ["Í≥†Í∏∞Ïïï", "Ï†ÄÍ∏∞Ïïï", "Í∞ôÏùÄ Í∏∞Ïïï", "ÏÉÅÍ¥ÄÏóÜÏùå"],
            correctAnswer: "Ï†ÄÍ∏∞Ïïï",
        },
        {
            question: "ÌïúÍµ≠Ïùò Ïó¨Î¶Ñ Í≥ÑÏ†àÏùò ÌäπÏßïÏúºÎ°ú ÏïåÎßûÏùÄ Í≤ÉÏùÄ?",
            options: [
            "Ï∞®Í≥† Í±¥Ï°∞Ìïú Í≥µÍ∏∞ Îç©Ïñ¥Î¶¨Í∞Ä ÏòÅÌñ•ÏùÑ Ï§ÄÎã§.",
            "Îî∞ÎúªÌïòÍ≥† ÏäµÎèÑÍ∞Ä ÎÜíÏùÄ Í≥µÍ∏∞ Îç©Ïñ¥Î¶¨Í∞Ä ÏòÅÌñ•ÏùÑ Ï§ÄÎã§.",
            "Ïù¥ÎèôÏÑ± Í≥†Í∏∞ÏïïÏùò ÏòÅÌñ•ÏùÑ ÏûêÏ£º Î∞õÎäîÎã§.",
            "ÎÇ†Ïî®Í∞Ä Îß§Ïö∞ Ï∂•Í≥† Í±¥Ï°∞ÌïòÎã§.",
            ],
            correctAnswer: "Îî∞ÎúªÌïòÍ≥† ÏäµÎèÑÍ∞Ä ÎÜíÏùÄ Í≥µÍ∏∞ Îç©Ïñ¥Î¶¨Í∞Ä ÏòÅÌñ•ÏùÑ Ï§ÄÎã§.",
        },
      ];

      // --- Sound Logic ---
      let audioContext = null;

      const getAudioContext = () => {
        if (!audioContext || audioContext.state === 'closed') {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.error("Web Audio API is not supported");
                return null;
            }
        }
        if (audioContext.state === 'suspended') {
            audioContext.resume();
        }
        return audioContext;
      };

      const play = (type, freq, duration, vol, attack = 0.01, decay = 0.05) => {
        const ctx = getAudioContext();
        if (!ctx) return;
        
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        
        gain.gain.setValueAtTime(0, ctx.currentTime);
        gain.gain.linearRampToValueAtTime(vol, ctx.currentTime + attack);
        gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + duration - decay);

        osc.connect(gain);
        gain.connect(ctx.destination);
        
        osc.start();
        osc.stop(ctx.currentTime + duration);
      };

      const playClickSound = () => play('sine', 880, 0.1, 0.1);
      const playSelectSound = () => play('triangle', 660, 0.15, 0.2);
      const playSwapSound = () => play('sine', 523.25, 0.2, 0.2);
      const playInvalidSwapSound = () => play('sawtooth', 150, 0.25, 0.2);
      const playMatchSound = () => play('sine', 783.99, 0.2, 0.3);
      const playComboSound = () => {
        play('sine', 783.99, 0.15, 0.3);
        setTimeout(() => play('sine', 987.77, 0.15, 0.3), 80);
        setTimeout(() => play('sine', 1318.51, 0.15, 0.3), 160);
      };
      const playFallSound = () => play('sine', 200, 0.2, 0.05);
      const playGameOverSound = () => {
        play('sawtooth', 440, 0.2, 0.4);
        setTimeout(() => play('sawtooth', 330, 0.2, 0.4), 200);
        setTimeout(() => play('sawtooth', 220, 0.4, 0.4), 400);
      };
      const playBombSound = () => play('sawtooth', 100, 0.6, 0.5);
      const playPieceExplodeSound = () => play('square', Math.random() * 200 + 100, 0.15, 0.2);
      const playCorrectAnswerSound = () => {
        play('sine', 523.25, 0.15, 0.4);
        setTimeout(() => play('sine', 659.25, 0.15, 0.4), 150);
        setTimeout(() => play('sine', 783.99, 0.2, 0.4), 300);
      };
      const playIncorrectAnswerSound = () => {
        play('square', 220, 0.2, 0.3);
        setTimeout(() => play('square', 164.81, 0.3, 0.3), 200);
      };

      // --- BGM Logic ---
      let isBgmPlaying = false;
      let nextNoteTime = 0.0;
      const lookahead = 50.0; 
      const scheduleAheadTime = 0.2;
      let bgmTimerID = null;
      let current16thNote = 0;
      const tempo = 135.0;

      // C Major scale notes
      const scale = [
          130.81, 146.83, 164.81, 174.61, 196.00, 220.00, 246.94,
          261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 
          523.25, 587.33, 659.25, 698.46, 783.99, 880.00, 987.77,
          1046.50
      ];

      const total16thNotes = 16 * 16;
      const chordProgressionByBar = [
          0, 4, 5, 3, 0, 3, 0, 4,
          0, 4, 5, 3, 0, 3, 0, 4,
      ].map(c => c + 7);

      const glockenspielMelody = [
          14, 16, 18, 16, 14, -1, 14, -1, 12, 11, 12, 14, 12, -1, 11, -1,
          11, 12, 14, 12, 11, -1, 11, -1, 12, 9, 11, 12, 9, -1, 7, -1,
          14, 16, 18, 16, 14, -1, 14, -1, 16, 14, 12, 11, 12, -1, 14, -1,
          14, 12, 11, 9, 7, 9, 11, 9, 7, -1, 7, -1, -1, -1, -1, -1,
          14, 16, 18, 19, 21, 19, 18, 16, 18, 16, 14, 12, 14, -1, 12, -1,
          11, 12, 14, 16, 14, 12, 11, -1, 12, 9, 11, 12, 9, -1, 7, -1,
          14, 14, 12, 12, 11, 11, 9, 9, 7, 9, 11, 12, 14, 16, 18, 19,
          21, 19, 18, 16, 14, 12, 11, 12, 11, -1, -1, -1, -1, -1, -1, -1,
      ];
      const fullMelody = [...glockenspielMelody, ...glockenspielMelody];

      function nextNote() {
          const secondsPerBeat = 60.0 / tempo;
          nextNoteTime += 0.25 * secondsPerBeat;
          current16thNote++;
      }

      function playDrum(type, time, volume = 1.0) {
          const ctx = getAudioContext();
          if (!ctx) return;
          if (type === 'kick') {
              const osc = ctx.createOscillator();
              const gain = ctx.createGain();
              osc.frequency.setValueAtTime(120, time);
              osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.15);
              gain.gain.setValueAtTime(0.64 * volume, time);
              gain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
              osc.connect(gain);
              gain.connect(ctx.destination);
              osc.start(time);
              osc.stop(time + 0.15);
          } else if (type === 'snare') {
              const bufferSize = ctx.sampleRate * 0.2;
              const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
              const output = buffer.getChannelData(0);
              for (let i = 0; i < bufferSize; i++) {
                  output[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
              }
              const source = ctx.createBufferSource();
              source.buffer = buffer;
              const gain = ctx.createGain();
              gain.gain.setValueAtTime(0.4 * volume, time);
              gain.gain.exponentialRampToValueAtTime(0.01, time + 0.18);
              source.connect(gain);
              gain.connect(ctx.destination);
              source.start(time);
              source.stop(time + 0.18);
          } else if (type === 'hat') {
              const noiseSource = ctx.createBufferSource();
              const bufferSize = ctx.sampleRate * 0.1;
              const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
              const output = buffer.getChannelData(0);
              for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; }
              noiseSource.buffer = buffer;
              const filter = ctx.createBiquadFilter();
              filter.type = 'highpass';
              filter.frequency.value = 7000;
              const gain = ctx.createGain();
              gain.gain.setValueAtTime(0.12 * volume, time);
              gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
              noiseSource.connect(filter);
              filter.connect(gain);
              gain.connect(ctx.destination);
              noiseSource.start(time);
              noiseSource.stop(time + 0.05);
          }
      }

      function scheduleNote(beatNumber, time) {
          const ctx = getAudioContext();
          if(!ctx) return;
          const beatInLoop = beatNumber % total16thNotes;
          const barNumber = Math.floor(beatInLoop / 16);
          const beatInBar = beatInLoop % 16;
          // Drums
          if (beatInBar % 4 === 0) playDrum('kick', time);
          if (beatInBar % 8 === 4) playDrum('snare', time);
          if (beatInBar % 2 === 1) playDrum('hat', time, 0.8);
          // Bass
          if (beatInBar % 4 === 0) {
              const bassOsc = ctx.createOscillator();
              const bassGain = ctx.createGain();
              bassOsc.type = 'sine';
              bassOsc.frequency.value = scale[chordProgressionByBar[barNumber] - 7];
              bassGain.gain.setValueAtTime(0.48, time);
              bassGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
              bassOsc.connect(bassGain);
              bassGain.connect(ctx.destination);
              bassOsc.start(time);
              bassOsc.stop(time + 0.2);
          }
          // Pad
          if (beatInBar % 16 === 0) {
              const chordRootIndex = chordProgressionByBar[barNumber];
              const chordTones = [chordRootIndex, chordRootIndex + 2, chordRootIndex + 4];
              chordTones.forEach(toneIndex => {
                  const padOsc = ctx.createOscillator();
                  const padGain = ctx.createGain();
                  padOsc.type = 'triangle';
                  padOsc.frequency.value = scale[toneIndex];
                  padGain.gain.setValueAtTime(0.001, time);
                  padGain.gain.linearRampToValueAtTime(0.08, time + 0.5);
                  padGain.gain.linearRampToValueAtTime(0.001, time + 1.8);
                  padOsc.connect(padGain);
                  padGain.connect(ctx.destination);
                  padOsc.start(time);
                  padOsc.stop(time + 1.8);
              });
          }
          // Melody
          const melodyNoteIndex = fullMelody[beatInLoop];
          if (melodyNoteIndex !== -1) {
              const glockOsc = ctx.createOscillator();
              const glockGain = ctx.createGain();
              glockOsc.type = 'sine';
              glockOsc.frequency.value = scale[melodyNoteIndex + 7];
              glockGain.gain.setValueAtTime(0.32, time);
              glockGain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
              glockOsc.connect(glockGain);
              glockGain.connect(ctx.destination);
              glockOsc.start(time);
              glockOsc.stop(time + 0.5);

              const pianoOsc = ctx.createOscillator();
              const pianoGain = ctx.createGain();
              pianoOsc.type = 'triangle';
              pianoOsc.frequency.value = scale[melodyNoteIndex];
              pianoGain.gain.setValueAtTime(0.16, time);
              pianoGain.gain.exponentialRampToValueAtTime(0.01, time + 0.4);
              pianoOsc.connect(pianoGain);
              pianoGain.connect(ctx.destination);
              pianoOsc.start(time);
              pianoOsc.stop(time + 0.4);
          }
      }

      function scheduler() {
          const ctx = getAudioContext();
          if(!ctx || !isBgmPlaying) return;
          if (ctx.state === 'suspended') {
              ctx.resume().catch(e => console.error("Error resuming AudioContext:", e));
          }
          while (nextNoteTime < ctx.currentTime + scheduleAheadTime) {
              scheduleNote(current16thNote, nextNoteTime);
              nextNote();
          }
          bgmTimerID = window.setTimeout(scheduler, lookahead);
      }

      const playBGM = async () => {
          const ctx = getAudioContext();
          if (!ctx) return;
          if (isBgmPlaying) stopBGM();
          if (ctx.state === 'suspended') await ctx.resume();
          isBgmPlaying = true;
          current16thNote = 0;
          nextNoteTime = ctx.currentTime + 0.1;
          scheduler();
      };

      const stopBGM = () => {
          if (!isBgmPlaying) return;
          isBgmPlaying = false;
          if (bgmTimerID) {
              window.clearTimeout(bgmTimerID);
              bgmTimerID = null;
          }
      };

      // --- Components ---

      // Button
      const Button = ({ onClick, children, variant = 'primary', className = '' }) => {
        const handleClick = () => {
          playClickSound();
          onClick();
        };
        const baseClasses = "w-full font-bold text-lg sm:text-xl py-3 px-6 rounded-full shadow-lg transform hover:-translate-y-1 transition-all duration-300 ease-in-out focus:outline-none focus:ring-4";
        const variantClasses = {
          primary: "bg-yellow-400 text-slate-800 hover:bg-yellow-500 focus:ring-yellow-300",
          secondary: "bg-sky-500 text-white hover:bg-sky-600 focus:ring-sky-300",
        };
        return (
          <button onClick={handleClick} className={`${baseClasses} ${variantClasses[variant]} ${className}`}>
            {children}
          </button>
        );
      };

      // AnimalPiece (Game Icon)
      const AnimalPiece = ({ piece, row, col, isSelected, isMatched, isNew, isExploding, isHint, onClick, size, gap }) => {
        const top = row * (size + gap);
        const left = col * (size + gap);
        const style = {
          position: 'absolute',
          top: `${isNew ? -size * 2 : top}px`,
          left: `${left}px`,
          width: `${size}px`,
          height: `${size}px`,
          transition: 'top 0.3s ease-in-out, left 0.3s ease-in-out, transform 0.2s ease, opacity 0.3s ease',
          fontSize: `${size * 0.7}px`,
          zIndex: isSelected ? 10 : 1,
        };
        let classNames = [
          'flex', 'items-center', 'justify-center', 'rounded-lg', 'cursor-pointer',
          'shadow-md', 'backdrop-blur-sm', 'border-2', 'border-white/50'
        ];
        if (!isHint) classNames.push('bg-white/80');
        if (isSelected) classNames.push('scale-110', 'shadow-xl', 'ring-4', 'ring-yellow-400');
        if (isMatched) classNames.push('opacity-0', 'scale-0');
        if (isExploding) classNames.push('animate-bomb-explode');
        if (isHint) classNames.push('animate-hint-glow');

        const pieceStyle = {
          filter: `drop-shadow(0 1.5px 0 #000) drop-shadow(0 -1.5px 0 #000) drop-shadow(1.5px 0 0 #000) drop-shadow(-1.5px 0 0 #000)`
        };

        return (
          <div onClick={onClick} style={style} className={classNames.join(' ')}>
            <span className="drop-shadow-lg" style={pieceStyle}>{piece}</span>
          </div>
        );
      };

      // Scoreboard
      const Scoreboard = ({ score, movesLeft }) => {
        return (
          <div className="flex justify-around bg-slate-100/80 p-3 rounded-xl shadow-inner backdrop-blur-sm">
            <div className="text-center w-1/2">
              <div className="text-lg sm:text-xl font-bold text-slate-600 uppercase tracking-wider">Ï†êÏàò</div>
              <div className="text-3xl sm:text-4xl font-fredoka text-sky-600 drop-shadow">{score}</div>
            </div>
            <div className="text-center w-1/2">
              <div className="text-lg sm:text-xl font-bold text-slate-600 uppercase tracking-wider">Ïù¥Îèô</div>
              <div className="text-3xl sm:text-4xl font-fredoka text-sky-600 drop-shadow">{movesLeft}</div>
            </div>
          </div>
        );
      };

      // GameOverModal
      const GameOverModal = ({ score, onRestart, onGoToMenu }) => {
        useEffect(() => { playGameOverSound(); }, []);
        return (
          <div className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50">
            <div className="bg-white rounded-3xl shadow-2xl p-8 text-center w-80 transform transition-all animate-in slide-in-from-bottom-10 duration-500">
              <h2 className="text-4xl sm:text-5xl font-fredoka text-sky-600">Í≤åÏûÑ Ï¢ÖÎ£å!</h2>
              <p className="text-slate-500 mt-2 text-base sm:text-lg">Ï†ïÎßê ÏûòÌñàÏñ¥Ïöî!</p>
              <div className="mt-6">
                <div className="text-lg sm:text-xl font-bold text-slate-600">ÏµúÏ¢Ö Ï†êÏàò</div>
                <div className="text-6xl sm:text-7xl font-fredoka text-yellow-500 my-2 drop-shadow">{score}</div>
              </div>
              <div className="mt-8 space-y-3">
                <Button onClick={onRestart} variant="primary">Îã§ÏãúÌïòÍ∏∞</Button>
                <Button onClick={onGoToMenu} variant="secondary">ÌÖåÎßà ÏÑ†ÌÉù</Button>
              </div>
            </div>
          </div>
        );
      };

      // ThemeSelection
      const ThemeSelection = ({ onSelectTheme }) => {
        const handleThemeClick = (theme) => {
          playClickSound();
          onSelectTheme(theme);
        };
        const iconStyle = {
          filter: `drop-shadow(0 2px 0 #000) drop-shadow(0 -2px 0 #000) drop-shadow(2px 0 0 #000) drop-shadow(-2px 0 0 #000)`
        };
        return (
          <div className="w-full max-w-md mx-auto animate-in fade-in duration-500">
            <h2 className="text-2xl sm:text-3xl font-bold text-center text-sky-700 mb-6">ÌÖåÎßàÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî!</h2>
            <div className="grid grid-cols-1 gap-4">
              {THEMES.map((theme) => (
                <button
                  key={theme.name}
                  onClick={() => handleThemeClick(theme)}
                  className="flex items-center p-4 bg-slate-50 rounded-xl shadow-md border border-slate-200 hover:bg-sky-100 transform hover:scale-105 transition-all duration-300 focus:outline-none focus:ring-4 focus:ring-yellow-300"
                >
                  <span className="text-4xl sm:text-5xl mr-4" style={iconStyle}>{theme.icon}</span>
                  <span className="text-lg sm:text-xl font-semibold text-slate-700">{theme.name}</span>
                </button>
              ))}
            </div>
          </div>
        );
      };

      // QuizModal
      const QuizModal = ({ question, onAnswer, onClose }) => {
        const [selectedAnswer, setSelectedAnswer] = useState(null);
        const [isCorrect, setIsCorrect] = useState(null);

        const handleAnswerClick = (option) => {
          if (selectedAnswer) return;
          playClickSound();
          const correct = option === question.correctAnswer;
          setSelectedAnswer(option);
          setIsCorrect(correct);
          onAnswer(correct);
          if (correct) playCorrectAnswerSound();
          else playIncorrectAnswerSound();
          setTimeout(() => onClose(), 1500);
        };

        const getButtonClass = (option) => {
          if (selectedAnswer === null) return 'bg-slate-100 hover:bg-slate-200 focus:ring-sky-300 text-slate-800';
          if (option === question.correctAnswer) return 'bg-green-500 text-white animate-pulse';
          if (option === selectedAnswer && !isCorrect) return 'bg-red-500 text-white';
          return 'bg-slate-100 text-slate-400 opacity-70';
        };

        return (
          <div className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 p-4">
            <div className="bg-white rounded-3xl shadow-2xl p-6 sm:p-8 text-center w-full max-w-md sm:max-w-lg transform transition-all animate-in slide-in-from-bottom-10 duration-500">
              <h2 className="text-2xl sm:text-3xl md:text-4xl font-bold text-sky-800 mb-4">{question.question}</h2>
              <div className="mt-6 grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-4">
                {question.options.map((option) => (
                  <button
                    key={option}
                    onClick={() => handleAnswerClick(option)}
                    disabled={selectedAnswer !== null}
                    className={`w-full font-bold text-2xl sm:text-3xl md:text-4xl py-3 px-4 rounded-xl shadow-md transform transition-all duration-300 ease-in-out focus:outline-none focus:ring-4 disabled:cursor-not-allowed ${getButtonClass(option)}`}
                  >
                    {option}
                  </button>
                ))}
              </div>
              {selectedAnswer !== null && (
                <div className="mt-6 font-bold text-xl sm:text-2xl animate-in fade-in duration-300">
                  {isCorrect ? <p className="text-green-500">Ï†ïÎãµÏûÖÎãàÎã§! (+100Ï†ê)</p> : <p className="text-red-500">ÏïÑÏâ¨ÏõåÏöî!</p>}
                </div>
              )}
            </div>
          </div>
        );
      };

      // GameBoard
      const GAP = 4;
      const delay = (ms) => new Promise(res => setTimeout(res, ms));

      const GameBoard = ({ setScore, movesLeft, setMovesLeft, onGameOver, isGameActive, themePieces, onSuccessfulMatch }) => {
        const [pieces, setPieces] = useState([]);
        const [selectedPiece, setSelectedPiece] = useState(null);
        const [isProcessing, setIsProcessing] = useState(true);
        const [pieceSize, setPieceSize] = useState(40);
        const [hint, setHint] = useState(null);
        const pieceIdCounter = useRef(0);
        const boardStateRef = useRef(pieces);
        const boardRef = useRef(null);
        const inactivityTimerRef = useRef(null);

        useEffect(() => { boardStateRef.current = pieces; }, [pieces]);

        useEffect(() => {
          const boardEl = boardRef.current;
          if (!boardEl) return;
          const calculateSize = () => {
              const boardWidth = boardEl.offsetWidth;
              const newSize = (boardWidth - (BOARD_SIZE - 1) * GAP) / BOARD_SIZE;
              setPieceSize(newSize);
          };
          const resizeObserver = new ResizeObserver(calculateSize);
          resizeObserver.observe(boardEl);
          calculateSize();
          return () => resizeObserver.disconnect();
        }, []);

        const createBoard = useCallback(() => {
          const newPieces = [];
          for (let row = 0; row < BOARD_SIZE; row++) {
            for (let col = 0; col < BOARD_SIZE; col++) {
              newPieces.push({
                id: pieceIdCounter.current++,
                value: themePieces[Math.floor(Math.random() * themePieces.length)],
                row, col, isNew: true,
              });
            }
          }
          return newPieces;
        }, [themePieces]);

        const findMatches = useCallback((currentPieces) => {
          const matches = new Set();
          const board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));
          currentPieces.forEach(p => {
              if(p.row >= 0 && p.col >= 0 && p.row < BOARD_SIZE && p.col < BOARD_SIZE) board[p.row][p.col] = p;
          });

          for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
              const piece = board[r][c];
              if (!piece || piece.value === BOMB_ICON) continue;
              
              if (c < BOARD_SIZE - (MIN_MATCH_LENGTH - 1)) {
                  const line = [piece];
                  for (let i = 1; c + i < BOARD_SIZE && board[r][c+i]?.value === piece.value; i++) line.push(board[r][c+i]);
                  if (line.length >= MIN_MATCH_LENGTH) line.forEach(p => matches.add(p));
              }

              if (r < BOARD_SIZE - (MIN_MATCH_LENGTH - 1)) {
                  const line = [piece];
                  for (let i = 1; r + i < BOARD_SIZE && board[r+i]?.[c]?.value === piece.value; i++) line.push(board[r+i][c]);
                  if (line.length >= MIN_MATCH_LENGTH) line.forEach(p => matches.add(p));
              }
            }
          }
          return Array.from(matches);
        }, []);

        const findPossibleMoves = useCallback((currentPieces) => {
          const board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));
          currentPieces.forEach(p => {
              if(p.row >= 0 && p.col >= 0 && p.row < BOARD_SIZE && p.col < BOARD_SIZE) board[p.row][p.col] = p;
          });
          const testSwap = (r1, c1, r2, c2) => {
            const piece1 = board[r1][c1];
            const piece2 = board[r2][c2];
            if (!piece1 || !piece2 || piece1.value === BOMB_ICON || piece2.value === BOMB_ICON) return false;
            const tempPieces = currentPieces.map(p => {
                if (p.id === piece1.id) return { ...p, row: r2, col: c2 };
                if (p.id === piece2.id) return { ...p, row: r1, col: c1 };
                return p;
            });
            return findMatches(tempPieces).length > 0;
          };
          for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
              if (c < BOARD_SIZE - 1 && testSwap(r, c, r, c + 1)) return [board[r][c], board[r][c + 1]];
              if (r < BOARD_SIZE - 1 && testSwap(r, c, r + 1, c)) return [board[r][c], board[r + 1][c]];
            }
          }
          return null;
        }, [findMatches]);

        const showHint = useCallback(() => {
          const possibleMove = findPossibleMoves(boardStateRef.current);
          if (possibleMove) setHint(new Set(possibleMove.map(p => p.id)));
        }, [findPossibleMoves]);

        const clearHint = useCallback(() => setHint(null), []);

        const resetInactivityTimer = useCallback(() => {
          if (inactivityTimerRef.current) clearTimeout(inactivityTimerRef.current);
          clearHint();
          if (isGameActive) inactivityTimerRef.current = window.setTimeout(showHint, 10000);
        }, [isGameActive, showHint, clearHint]);

        useEffect(() => {
          resetInactivityTimer();
          return () => { if (inactivityTimerRef.current) clearTimeout(inactivityTimerRef.current); };
        }, [isGameActive, resetInactivityTimer]);

        const handleMatchesAndRefill = useCallback(async (initialMatches, isBombStart = false) => {
          if (initialMatches.length === 0) return;
          let currentMatches = [...initialMatches];
          let combo = 0;
          
          while (currentMatches.length > 0) {
              combo++;
              const isBombTrigger = isBombStart && combo === 1;

              if (isBombTrigger) {
                  const shuffledExplosions = [...currentMatches].sort(() => Math.random() - 0.5);
                  setScore(prev => prev + shuffledExplosions.length * 15);
                  for (const piece of shuffledExplosions) {
                      await delay(60);
                      playPieceExplodeSound();
                      setPieces(currentBoard => currentBoard.map(p => p.id === piece.id ? { ...p, isExploding: true } : p));
                  }
              } else {
                  if (combo > 1) playComboSound();
                  else if (!isBombStart) playMatchSound();
                  setScore(prev => prev + currentMatches.length * 10 * combo);
                  setPieces(prev => prev.map(p => {
                      const match = currentMatches.find(m => m.id === p.id);
                      if (match) return { ...p, isMatched: true };
                      return p;
                  }));
              }
              await delay(400);

              const currentBoard = boardStateRef.current;
              const removedPieceIds = new Set(currentMatches.map(p => p.id));
              const remaining = currentBoard.filter(p => !removedPieceIds.has(p.id));
              const nextPieces = [];

              for (let c = 0; c < BOARD_SIZE; c++) {
                  const piecesInCol = remaining.filter(p => p.col === c).sort((a,b) => b.row - a.row);
                  for (let i = 0; i < piecesInCol.length; i++) {
                      nextPieces.push({ ...piecesInCol[i], row: BOARD_SIZE - 1 - i });
                  }
                  const numToFill = BOARD_SIZE - piecesInCol.length;
                  for (let r = 0; r < numToFill; r++) {
                      const isBomb = Math.random() < BOMB_CHANCE;
                      nextPieces.push({
                          id: pieceIdCounter.current++,
                          value: isBomb ? BOMB_ICON : themePieces[Math.floor(Math.random() * themePieces.length)],
                          col: c,
                          row: r,
                          isNew: true,
                      });
                  }
              }
              playFallSound();
              setPieces(nextPieces);
              await delay(10);
              setPieces(prev => prev.map(p => ({...p, isNew: false, isExploding: false })));
              await delay(500);

              currentMatches = findMatches(boardStateRef.current);
              if(currentMatches.length > 0 && !isBombStart) onSuccessfulMatch();
          }
        }, [findMatches, setScore, themePieces, onSuccessfulMatch]);

        useEffect(() => {
          const setupBoard = async () => {
              setIsProcessing(true);
              let initialPieces;
              while (true) {
                  initialPieces = createBoard();
                  if (findMatches(initialPieces).length === 0 && findPossibleMoves(initialPieces)) break;
              }
              setPieces(initialPieces);
              await delay(50);
              setPieces(prev => prev.map(p => ({ ...p, isNew: false })));
              await delay(500); 
              setIsProcessing(false);
          }
          setupBoard();
        }, [createBoard, findMatches, findPossibleMoves]);

        useEffect(() => {
          if (isGameActive && movesLeft <= 0) onGameOver();
        }, [movesLeft, isGameActive, onGameOver]);

        const handlePieceClick = useCallback(async (piece) => {
          if (isProcessing || !isGameActive) return;
          resetInactivityTimer();
          if (!selectedPiece) {
            playSelectSound();
            setSelectedPiece(piece);
            return;
          }
          const isAdjacent = Math.abs(selectedPiece.row - piece.row) + Math.abs(selectedPiece.col - piece.col) === 1;
          if (isAdjacent) {
            setIsProcessing(true);
            const newPieces = pieces.map(p => {
              if (p.id === selectedPiece.id) return { ...p, row: piece.row, col: piece.col };
              if (p.id === piece.id) return { ...p, row: selectedPiece.row, col: selectedPiece.col };
              return p;
            });
            setPieces(newPieces);
            
            let matchesAfterSwap = [];
            const swappedPiece1 = newPieces.find(p => p.id === selectedPiece.id);
            const swappedPiece2 = newPieces.find(p => p.id === piece.id);
            
            let bombActivated = false;
            let bombCenter = null;
            
            if (swappedPiece1?.value === BOMB_ICON) {
              bombActivated = true;
              bombCenter = { row: swappedPiece1.row, col: swappedPiece1.col };
            } else if (swappedPiece2?.value === BOMB_ICON) {
              bombActivated = true;
              bombCenter = { row: swappedPiece2.row, col: swappedPiece2.col };
            }

            if (bombActivated && bombCenter) {
              playBombSound();
              const affectedPieces = new Set();
              for (let r = bombCenter.row - 1; r <= bombCenter.row + 1; r++) {
                for (let c = bombCenter.col - 1; c <= bombCenter.col + 1; c++) {
                  if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                    const victim = newPieces.find(p => p.row === r && p.col === c);
                    if (victim) affectedPieces.add(victim);
                  }
                }
              }
              matchesAfterSwap = Array.from(affectedPieces);
            } else {
              matchesAfterSwap = findMatches(newPieces);
            }
            
            if (matchesAfterSwap.length > 0) {
              playSwapSound();
              setMovesLeft(prev => prev - 1);
              await delay(300);
              await handleMatchesAndRefill(matchesAfterSwap, bombActivated);
              onSuccessfulMatch();
            } else {
              playInvalidSwapSound();
              await delay(300);
              setPieces(pieces);
            }
            setSelectedPiece(null);
            setIsProcessing(false);
          } else {
            playSelectSound();
            setSelectedPiece(piece);
          }
        }, [selectedPiece, isProcessing, isGameActive, pieces, findMatches, setMovesLeft, handleMatchesAndRefill, onSuccessfulMatch, resetInactivityTimer]);

        return (
          <div className="bg-sky-200/70 p-1 rounded-2xl shadow-inner w-full">
            <div ref={boardRef} className="relative w-full" style={{ aspectRatio: '1 / 1' }}>
              {pieces.map((p) => (
                <AnimalPiece
                  key={p.id}
                  piece={p.value}
                  row={p.row}
                  col={p.col}
                  isSelected={selectedPiece?.id === p.id}
                  isMatched={!!p.isMatched}
                  isNew={!!p.isNew}
                  isExploding={!!p.isExploding}
                  isHint={hint?.has(p.id) ?? false}
                  onClick={() => handlePieceClick(p)}
                  size={pieceSize}
                  gap={GAP}
                />
              ))}
            </div>
          </div>
        );
      };

      // App (Main)
      const App = () => {
        const [gameState, setGameState] = useState(GameState.Menu);
        const [score, setScore] = useState(0);
        const [movesLeft, setMovesLeft] = useState(INITIAL_MOVES);
        const [currentTheme, setCurrentTheme] = useState(null);
        const [gameId, setGameId] = useState(0);
        const [currentQuiz, setCurrentQuiz] = useState(null);
        const [matchCount, setMatchCount] = useState(0);
        const askedQuizIndexes = useRef(new Set());

        const resetQuiz = () => {
          setCurrentQuiz(null);
          askedQuizIndexes.current.clear();
          setMatchCount(0);
        };
        
        const handleThemeSelect = useCallback((theme) => {
          setCurrentTheme(theme);
          setGameId(prevId => prevId + 1);
          setScore(0);
          setMovesLeft(INITIAL_MOVES);
          setGameState(GameState.Playing);
          resetQuiz();
          playBGM();
        }, []);
        
        const restartGame = useCallback(() => {
          setGameId(prevId => prevId + 1);
          setScore(0);
          setMovesLeft(INITIAL_MOVES);
          setGameState(GameState.Playing);
          resetQuiz();
          playBGM();
        }, []);

        const handleGoToMenu = useCallback(() => {
          setCurrentTheme(null);
          setGameState(GameState.Menu);
          resetQuiz();
          stopBGM();
        }, []);

        const handleGoToMenuWithSound = useCallback(() => {
          playClickSound();
          handleGoToMenu();
        }, [handleGoToMenu]);

        const handleGameOver = useCallback(() => {
          setGameState(GameState.GameOver);
          stopBGM();
        }, []);
        
        const handleSuccessfulMatch = useCallback(() => {
          setMatchCount(prevCount => {
              const newCount = prevCount + 1;
              if (newCount > 0 && newCount % 5 === 0) {
                  if (askedQuizIndexes.current.size === QUIZ_QUESTIONS.length) {
                      askedQuizIndexes.current.clear();
                  }

                  let quizIndex;
                  do {
                    quizIndex = Math.floor(Math.random() * QUIZ_QUESTIONS.length);
                  } while (askedQuizIndexes.current.has(quizIndex));
                  
                  askedQuizIndexes.current.add(quizIndex);
                  setCurrentQuiz(QUIZ_QUESTIONS[quizIndex]);
              }
              return newCount;
          });
        }, []);
        
        const handleQuizAnswer = useCallback((isCorrect) => {
          if (isCorrect) {
              setScore(prev => prev + 100);
          }
        }, []);
        
        const iconStyle = {
          filter: `drop-shadow(0 1px 0 #000) drop-shadow(0 -1px 0 #000) drop-shadow(1px 0 0 #000) drop-shadow(-1px 0 0 #000)`
        };

        return (
          <div className="min-h-screen bg-gradient-to-b from-sky-400 to-blue-500 flex flex-col items-center justify-center p-4 font-jua select-none">
            <div className="w-full max-w-md sm:max-w-lg md:max-w-xl mx-auto bg-white/95 backdrop-blur-sm rounded-3xl shadow-xl p-4 sm:p-6 md:p-8 border border-white/30">
              <header className="relative text-center mb-4">
                {gameState === GameState.Playing && (
                  <button
                    onClick={handleGoToMenuWithSound}
                    className="absolute left-4 top-[calc(50%+10px)] -translate-y-1/2 w-11 h-11 bg-gradient-to-b from-white to-slate-200 rounded-full shadow-xl hover:from-white hover:to-slate-100 transform transition-all duration-200 hover:scale-110 focus:outline-none focus:ring-2 focus:ring-sky-400 flex items-center justify-center border-2 border-slate-300"
                    aria-label="Î©îÏù∏ Î©îÎâ¥Î°ú ÎèåÏïÑÍ∞ÄÍ∏∞"
                  >
                    <span className="text-2xl drop-shadow-md" role="img" aria-hidden="true" style={iconStyle}>üè†</span>
                  </button>
                )}
                <h1 className="text-3xl sm:text-4xl md:text-5xl font-black-han text-sky-600 drop-shadow-md">Ï¥àÎì± 5ÌïôÎÖÑ ÎÇ†Ïî® Ìå°Ìå°</h1>
                {gameState !== GameState.Menu && currentTheme && (
                  <p className="text-slate-600 mt-2 text-base sm:text-lg">
                    ÌÖåÎßà: <span style={iconStyle}>{currentTheme.icon}</span> {currentTheme.name}
                  </p>
                )}
              </header>

              {gameState === GameState.Menu && <ThemeSelection onSelectTheme={handleThemeSelect} />}
              
              {gameState === GameState.Playing && currentTheme && (
                <div className="animate-in fade-in duration-500">
                  <Scoreboard score={score} movesLeft={movesLeft} />
                  <main className="mt-4 flex justify-center">
                    <GameBoard
                      key={gameId}
                      setScore={setScore}
                      movesLeft={movesLeft}
                      setMovesLeft={setMovesLeft}
                      onGameOver={handleGameOver}
                      isGameActive={gameState === GameState.Playing && !currentQuiz}
                      themePieces={currentTheme.pieces}
                      onSuccessfulMatch={handleSuccessfulMatch}
                    />
                  </main>
                </div>
              )}
            </div>
            
            {gameState === GameState.GameOver && (
              <GameOverModal score={score} onRestart={restartGame} onGoToMenu={handleGoToMenu}/>
            )}

            {currentQuiz && (
              <QuizModal 
                  question={currentQuiz}
                  onAnswer={handleQuizAnswer}
                  onClose={() => setCurrentQuiz(null)}
              />
            )}

            <footer className="text-center mt-6 text-white text-2xl sm:text-3xl drop-shadow-md">
              <p>Ïû¨ÎØ∏ÏûàÍ≤å Î∞∞Ïö∞Îäî ÎÇ†Ïî®ÏôÄ Í∏∞ÌõÑ</p>
            </footer>
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>